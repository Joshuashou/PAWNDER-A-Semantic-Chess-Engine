{"ast":null,"code":"import * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport { anim } from './anim.js';\nexport function start(s, e) {\n  if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n  if (e.buttons !== undefined && e.buttons > 1) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e),\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)) drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (e.cancelable !== false && (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))) e.preventDefault();else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = \"ghost \".concat(piece.color, \" \").concat(piece.role);\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\nfunction pieceCloseTo(s, pos) {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\nexport function dragNewPiece(s, piece, e, force) {\n  const key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n  const position = util.eventPosition(e);\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false\n  };\n  processDrag(s);\n}\nfunction processDrag(s) {\n  requestAnimationFrame(() => {\n    var _a;\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2)) cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [cur.pos[0] - bounds.left - bounds.width / 16, cur.pos[1] - bounds.top - bounds.height / 16]);\n        cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds));\n      }\n    }\n    processDrag(s);\n  });\n}\nexport function move(s, e) {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e);\n  }\n}\nexport function end(s, e) {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest)) board.unselect(s);else if (!s.selectable.enabled) board.unselect(s);\n  removeDragElements(s);\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\nexport function cancel(s) {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\nfunction removeDragElements(s) {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\nfunction pieceElementByKey(s, key) {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if (el.cgKey === key && el.tagName === 'PIECE') return el;\n    el = el.nextSibling;\n  }\n  return;\n}","map":{"version":3,"names":["board","util","clear","drawClear","anim","start","s","e","trustAllEvents","isTrusted","buttons","undefined","touches","length","bounds","dom","position","eventPosition","orig","getKeyAtDomPos","whitePov","piece","pieces","get","previouslySelected","selected","drawable","enabled","eraseOnClick","color","turnColor","cancelable","blockTouchScroll","pieceCloseTo","preventDefault","hadPremove","premovable","current","hadPredrop","predroppable","stats","ctrlKey","canMove","state","selectSquare","stillSelected","element","pieceElementByKey","isDraggable","draggable","origPos","pos","started","autoDistance","dragged","originTarget","target","keyHasChanged","cgDragging","classList","add","ghost","elements","className","concat","role","translate","posToTranslate","key2pos","setVisible","processDrag","unsetPremove","unsetPredrop","redraw","asWhite","radiusSq","Math","pow","width","key","keys","center","computeSquareCenter","distanceSq","dragNewPiece","force","set","newPiece","requestAnimationFrame","cur","_a","animation","plan","anims","has","origPiece","samePiece","cancel","distance","found","left","top","height","move","end","type","eventPos","dest","dropNewPiece","userMove","delete","deleteOnDropOff","callUserFunction","events","change","unselect","selectable","removeDragElements","el","firstChild","cgKey","tagName","nextSibling"],"sources":["/Users/joshuashou/Desktop/Personal/Semantic_Chess_Engine/node_modules/chessground/src/drag.ts"],"sourcesContent":["import { State } from './state.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport * as cg from './types.js';\nimport { anim } from './anim.js';\n\nexport interface DragCurrent {\n  orig: cg.Key; // orig key of dragging piece\n  piece: cg.Piece;\n  origPos: cg.NumberPair; // first event position\n  pos: cg.NumberPair; // latest event position\n  started: boolean; // whether the drag has started; as per the distance setting\n  element: cg.PieceNode | (() => cg.PieceNode | undefined);\n  newPiece?: boolean; // it it a new piece from outside the board\n  force?: boolean; // can the new piece replace an existing one (editor)\n  previouslySelected?: cg.Key;\n  originTarget: EventTarget | null;\n  keyHasChanged: boolean; // whether the drag has left the orig key\n}\n\nexport function start(s: State, e: cg.MouchEvent): void {\n  if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n  if (e.buttons !== undefined && e.buttons > 1) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e)!,\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (\n    !previouslySelected &&\n    s.drawable.enabled &&\n    (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)\n  )\n    drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (\n    e.cancelable !== false &&\n    (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))\n  )\n    e.preventDefault();\n  else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false,\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\n\nfunction pieceCloseTo(s: State, pos: cg.NumberPair): boolean {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\n\nexport function dragNewPiece(s: State, piece: cg.Piece, e: cg.MouchEvent, force?: boolean): void {\n  const key: cg.Key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n\n  const position = util.eventPosition(e)!;\n\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false,\n  };\n  processDrag(s);\n}\n\nfunction processDrag(s: State): void {\n  requestAnimationFrame(() => {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if (s.animation.current?.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);\n    else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n        cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [\n          cur.pos[0] - bounds.left - bounds.width / 16,\n          cur.pos[1] - bounds.top - bounds.height / 16,\n        ]);\n\n        cur.keyHasChanged ||= cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds);\n      }\n    }\n    processDrag(s);\n  });\n}\n\nexport function move(s: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e)!;\n  }\n}\n\nexport function end(s: State, e: cg.MouchEvent): void {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);\n    else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n    board.unselect(s);\n  else if (!s.selectable.enabled) board.unselect(s);\n\n  removeDragElements(s);\n\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\n\nexport function cancel(s: State): void {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\n\nfunction removeDragElements(s: State): void {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\n\nfunction pieceElementByKey(s: State, key: cg.Key): cg.PieceNode | undefined {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if ((el as cg.KeyedNode).cgKey === key && (el as cg.KeyedNode).tagName === 'PIECE')\n      return el as cg.PieceNode;\n    el = el.nextSibling;\n  }\n  return;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}