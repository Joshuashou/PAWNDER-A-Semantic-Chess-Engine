{"ast":null,"code":"import { start } from './api.js';\nimport { configure } from './config.js';\nimport { defaults } from './state.js';\nimport { renderWrap } from './wrap.js';\nimport * as events from './events.js';\nimport { render, renderResized, updateBounds } from './render.js';\nimport * as autoPieces from './autoPieces.js';\nimport * as svg from './svg.js';\nimport * as util from './util.js';\nexport function initModule({\n  el,\n  config\n}) {\n  return Chessground(el, config);\n}\nexport function Chessground(element, config) {\n  const maybeState = defaults();\n  configure(maybeState, config || {});\n  function redrawAll() {\n    const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n    // compute bounds from existing board element if possible\n    // this allows non-square boards from CSS to be handled (for 3D)\n    const elements = renderWrap(element, maybeState),\n      bounds = util.memo(() => elements.board.getBoundingClientRect()),\n      redrawNow = skipSvg => {\n        render(state);\n        if (elements.autoPieces) autoPieces.render(state, elements.autoPieces);\n        if (!skipSvg && elements.svg) svg.renderSvg(state, elements.svg, elements.customSvg);\n      },\n      onResize = () => {\n        updateBounds(state);\n        renderResized(state);\n        if (elements.autoPieces) autoPieces.renderResized(state);\n      };\n    const state = maybeState;\n    state.dom = {\n      elements,\n      bounds,\n      redraw: debounceRedraw(redrawNow),\n      redrawNow,\n      unbind: prevUnbind\n    };\n    state.drawable.prevSvgHash = '';\n    updateBounds(state);\n    redrawNow(false);\n    events.bindBoard(state, onResize);\n    if (!prevUnbind) state.dom.unbind = events.bindDocument(state, onResize);\n    state.events.insert && state.events.insert(elements);\n    return state;\n  }\n  return start(redrawAll(), redrawAll);\n}\nfunction debounceRedraw(redrawNow) {\n  let redrawing = false;\n  return () => {\n    if (redrawing) return;\n    redrawing = true;\n    requestAnimationFrame(() => {\n      redrawNow();\n      redrawing = false;\n    });\n  };\n}","map":{"version":3,"names":["start","configure","defaults","renderWrap","events","render","renderResized","updateBounds","autoPieces","svg","util","initModule","el","config","Chessground","element","maybeState","redrawAll","prevUnbind","dom","unbind","undefined","elements","bounds","memo","board","getBoundingClientRect","redrawNow","skipSvg","state","renderSvg","customSvg","onResize","redraw","debounceRedraw","drawable","prevSvgHash","bindBoard","bindDocument","insert","redrawing","requestAnimationFrame"],"sources":["/Users/joshuashou/Desktop/Personal/Semantic_Chess_Engine/node_modules/chessground/src/chessground.ts"],"sourcesContent":["import { Api, start } from './api.js';\nimport { Config, configure } from './config.js';\nimport { HeadlessState, State, defaults } from './state.js';\n\nimport { renderWrap } from './wrap.js';\nimport * as events from './events.js';\nimport { render, renderResized, updateBounds } from './render.js';\nimport * as autoPieces from './autoPieces.js';\nimport * as svg from './svg.js';\nimport * as util from './util.js';\n\nexport function initModule({ el, config }: { el: HTMLElement; config?: Config }): Api {\n  return Chessground(el, config);\n}\n\nexport function Chessground(element: HTMLElement, config?: Config): Api {\n  const maybeState: State | HeadlessState = defaults();\n\n  configure(maybeState, config || {});\n\n  function redrawAll(): State {\n    const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n    // compute bounds from existing board element if possible\n    // this allows non-square boards from CSS to be handled (for 3D)\n    const elements = renderWrap(element, maybeState),\n      bounds = util.memo(() => elements.board.getBoundingClientRect()),\n      redrawNow = (skipSvg?: boolean): void => {\n        render(state);\n        if (elements.autoPieces) autoPieces.render(state, elements.autoPieces);\n        if (!skipSvg && elements.svg) svg.renderSvg(state, elements.svg, elements.customSvg!);\n      },\n      onResize = (): void => {\n        updateBounds(state);\n        renderResized(state);\n        if (elements.autoPieces) autoPieces.renderResized(state);\n      };\n    const state = maybeState as State;\n    state.dom = {\n      elements,\n      bounds,\n      redraw: debounceRedraw(redrawNow),\n      redrawNow,\n      unbind: prevUnbind,\n    };\n    state.drawable.prevSvgHash = '';\n    updateBounds(state);\n    redrawNow(false);\n    events.bindBoard(state, onResize);\n    if (!prevUnbind) state.dom.unbind = events.bindDocument(state, onResize);\n    state.events.insert && state.events.insert(elements);\n    return state;\n  }\n\n  return start(redrawAll(), redrawAll);\n}\n\nfunction debounceRedraw(redrawNow: (skipSvg?: boolean) => void): () => void {\n  let redrawing = false;\n  return () => {\n    if (redrawing) return;\n    redrawing = true;\n    requestAnimationFrame(() => {\n      redrawNow();\n      redrawing = false;\n    });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}